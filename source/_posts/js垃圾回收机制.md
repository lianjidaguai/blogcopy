---
layout: 'n'
title: js垃圾回收机制
date: 2019-06-04 12:02:38
tags:
   - js
   - 原理
---
 JavaScript 自动垃圾收集机制
垃圾回收又称为 GC(Garbage Collecation)。编写 JavaScript 程序时，开发者不需要手工跟踪内存的使用情况，只要按照标准写 JavaScript 代码，JavaScript 程序运行所需内存的分配以及无用内存的回收完全是自动管理。JavaScript 中自动垃圾回收机制的原理为：

找出那些不再使用的变量，然后释放其占用的内存。
垃圾收集器会按照固定的时间间隔(或预定的收集时间)周期性地执行此操作。

局部变量的正常生命周期
局部变量只在函数执行的过程中存在。
在函数执行过程中，会为局部变量在栈内存(或 堆内存)上分配相应的空间来存储它们的值。在函数中使用这些变量，直至函数执行结束，此时可以释放局部变量的内存供将来需要时使用。
以上情况下，较容易判断变量是否有存在的必要，更复杂的情况需要更精细的变量追踪策略。
JavaScript 中的垃圾收集器必须跟踪每个变量是否有用，需要为不再有用的变量打上标记，用于将来回收其占用的内存。标识无用变量的策略通常有两个：标记清除 和 引用计数 。
JavaScript 中的栈内存与堆内存
上述过程中，JavaScript 中变量分为 基本类型值 和 引用类型值：

基本类型值 在内存中占固定大小的空间，因此被保存在 栈内存 中；
引用类型值 是对象，保存在 堆内存 中。包含引用类型值的变量实际包含并非对象本身，而是指向该对象的指针。一个变量从另一个变量复制引用类型的值时，复制的也是指向该对象的指针。

标记清除
标记清除(mark-and-sweep) 是 JavaScript 中最常用的垃圾回收方式。其执行机制如下：

当变量进入环境时，就将其标记为“进入环境”
当变量离开环境时将其标记为“离开环境”

逻辑上，永远不能释放进入环境的变量所占用的内存，因为执行流进入相应的环境时，可能会用到它们。
标记变量的方式有很多种，可以使用标记位的形式记录变量进入环境，也可单独为“进入环境”和“离开环境”添加变量列表来记录变化。
标记清除采用的收集策略为：

JavaScript中的垃圾收集器运行时会给存储在内存中的所有变量都加上标记；
然后去掉环境中的变量以及被环境中的变量引用的变量的标记；
此后，再被加上标记的变量被视为准备删除的变量；
最后，垃圾收集器完成内存清除，销毁那些带标记的值并回收其占用的内存空间。

2008年之前，IE、Firefox、Opera、Chrome 和 Safari 的 JavaScript实现使用的均为 标记清除式的垃圾回收策略，区别可能在垃圾收集的时间间隔。
引用计数
引用计数(reference counting) 是另一种垃圾收集策略。引用计数的本质是 跟踪记录每个值被引用的次数。其执行机制如下：

当声明一个变量并将一个引用类型值赋值给该变量时，这个值的引用次数为1；
若同一个值(变量)又被赋值给另一个变量，则该值的引用次数加1；
但是如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1；
当这个值的引用次数为0时，则无法再访问这个值，就可回收其占用的内存空间。

垃圾收集器下次运行时，会释放那些引用次数为零的值所占用的内存。
引用计数存在一个致命的问题： 循环引用。循环引用是指，对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。下面的代码就是标准的循环引用的例子：
function cycleRefernce() {
    var objectA = new Object();
    var objectB = new Object();
    
    objectA.someOtherObject = objectB;
    objectB.anotherObject = objectA;
}
复制代码上述例子中 objectA 和 objectB 通过各自属性相互引用。按照引用计数的策略，两个对象的引用次数均为 2。若采用标记清除策略，函数执行完毕，对象离开作用域就不存在相互引用。但采用引用计数后，函数执行完，两个对象的引用次数永不为0，会一直存尊内存中，若多次调用，导致大量内存得不到回收。
IE8浏览器 之前中有一部分对象并不是原生的 JavaScript 对象，可能是使用 C++ 以 COM 对象的形式实现的(BOM, DOM)。而 COM 对象的垃圾收集机制采用的是 引用计数策略。即使 IE 的 JavaScript 引擎是使用标记清除策略实现的，但 JavaScript 访问 COM 对象仍然是基于 引用计数策略的。在这种情况下，只要在 IE 中涉及 COM 对象，就可能存在循环引用的问题。
为避免出现循环引用，最好在不使用这些对象时，手动断开 原生 JavaScript 对象 与 DOM 元素之间的连接。IE中的循环引用与手动断开的操作如下所示：
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;
// 以上 存在循环引用
// ...... 
// 以下 手工断开连接
myObject.element = null;
element.someObject =null;


作者：skylinebin
链接：https://juejin.im/post/5cf4d12ee51d45775746b8ea
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
